<?xml version='1.0' encoding='UTF-8' ?>

<!DOCTYPE rfc SYSTEM "rfc2629.dtd" [
<!-- One method to get references from the online citation libraries.
There has to be one entity for each item to be referenced.
An alternate method (rfc include) is described in the references. -->
<!ENTITY RFC5966 SYSTEM "http://xml2rfc.ietf.org/public/rfc/bibxml/reference.RFC.5966.xml">
<!ENTITY RFC0768 PUBLIC '' "http://xml2rfc.ietf.org/public/rfc/bibxml/reference.RFC.0768.xml">
<!ENTITY RFC0793 PUBLIC '' "http://xml2rfc.ietf.org/public/rfc/bibxml/reference.RFC.0793.xml">
<!ENTITY RFC1034 PUBLIC '' "http://xml2rfc.ietf.org/public/rfc/bibxml/reference.RFC.1034.xml">
<!ENTITY RFC1035 PUBLIC '' "http://xml2rfc.ietf.org/public/rfc/bibxml/reference.RFC.1035.xml">
<!ENTITY RFC1123 PUBLIC '' "http://xml2rfc.ietf.org/public/rfc/bibxml/reference.RFC.1123.xml">
<!ENTITY RFC2119 PUBLIC '' "http://xml2rfc.ietf.org/public/rfc/bibxml/reference.RFC.2119.xml">
<!ENTITY RFC2119 PUBLIC '' "http://xml2rfc.ietf.org/public/rfc/bibxml/reference.RFC.2119.xml">
<!ENTITY RFC2616 PUBLIC '' "http://xml2rfc.ietf.org/public/rfc/bibxml/reference.RFC.2616.xml">
<!ENTITY RFC2629 PUBLIC '' "http://xml2rfc.ietf.org/public/rfc/bibxml/reference.RFC.2629.xml">
<!ENTITY RFC2671 PUBLIC '' "http://xml2rfc.ietf.org/public/rfc/bibxml/reference.RFC.2671.xml">
<!ENTITY RFC2920 PUBLIC '' "http://xml2rfc.ietf.org/public/rfc/bibxml/reference.RFC.2920.xml">
<!ENTITY RFC3552 PUBLIC '' "http://xml2rfc.ietf.org/public/rfc/bibxml/reference.RFC.3552.xml">
<!ENTITY RFC3757 PUBLIC '' "http://xml2rfc.ietf.org/public/rfc/bibxml/reference.RFC.3757.xml">
<!ENTITY RFC4033 PUBLIC '' "http://xml2rfc.ietf.org/public/rfc/bibxml/reference.RFC.4033.xml">
<!ENTITY RFC4034 PUBLIC '' "http://xml2rfc.ietf.org/public/rfc/bibxml/reference.RFC.4034.xml">
<!ENTITY RFC4035 PUBLIC '' "http://xml2rfc.ietf.org/public/rfc/bibxml/reference.RFC.4035.xml">
<!ENTITY RFC5011 PUBLIC '' "http://xml2rfc.ietf.org/public/rfc/bibxml/reference.RFC.5011.xml">
<!ENTITY RFC5155 PUBLIC '' "http://xml2rfc.ietf.org/public/rfc/bibxml/reference.RFC.5155.xml">
<!ENTITY RFC5358 PUBLIC '' "http://xml2rfc.ietf.org/public/rfc/bibxml/reference.RFC.5358.xml">
<!ENTITY RFC5625 PUBLIC '' "http://xml2rfc.ietf.org/public/rfc/bibxml/reference.RFC.5625.xml">
<!ENTITY RFC5625 PUBLIC '' "http://xml2rfc.ietf.org/public/rfc/bibxml/reference.RFC.5625.xml">
<!ENTITY RFC6824 PUBLIC '' "http://xml2rfc.ietf.org/public/rfc/bibxml/reference.RFC.6824.xml">
<!ENTITY RFC6891 PUBLIC '' "http://xml2rfc.ietf.org/public/rfc/bibxml/reference.RFC.6891.xml">
<!ENTITY RFC6975 PUBLIC '' "http://xml2rfc.ietf.org/public/rfc/bibxml/reference.RFC.6975.xml">
<!ENTITY RFC7230 PUBLIC '' "http://xml2rfc.ietf.org/public/rfc/bibxml/reference.RFC.7230.xml">
<!ENTITY RFC7323 PUBLIC '' "http://xml2rfc.ietf.org/public/rfc/bibxml/reference.RFC.7323.xml">
]>

<?xml-stylesheet type='text/xsl' href='rfc2629.xslt' ?>
<?rfc strict="yes" ?>
<?rfc toc="yes"?>
<?rfc tocdepth="4"?>
<?rfc symrefs="yes"?>
<?rfc sortrefs="yes" ?>
<?rfc compact="yes" ?>
<?rfc subcompact="no" ?>

<rfc category="std" docName="draft-ietf-dnsop-edns-key-tag-02" ipr="trust200902">
  <!-- category values: std, bcp, info, exp, and historic
  ipr values: full3667, noModification3667, noDerivatives3667
  you can add the attributes updates="NNNN" and obsoletes="NNNN"
  they will automatically be output with "(if approved)" -->

  <!-- ***** FRONT MATTER ***** -->

  <front>
    <!-- The abbreviated title is used in the page header - it is only necessary if the
    full title is longer than 39 characters -->

    <title abbrev="DNSSEC Key Tag Signalling">Signalling Trust Anchor Knowledge in DNS Security Extensions (DNSSEC)</title>

    <!-- add 'role="editor"' below for the editors if appropriate -->

    <!-- Another author who claims to be an editor -->

    <author fullname="Duane Wessels" initials="D." surname="Wessels">
      <organization>Verisign</organization>
      <address>
        <postal>
          <street>12061 Bluemont Way</street>
          <city>Reston</city>
          <region>VA</region>
          <code>20190</code>
	  <country>United States</country>
        </postal>
        <phone>+1 703 948-3200</phone>
        <email>dwessels@verisign.com</email>
        <uri>http://verisigninc.com</uri>
      </address>
    </author>

    <author fullname="Warren Kumari" initials="W." surname="Kumari">
      <organization>Google</organization>
      <address>
        <postal>
          <street>1600 Amphitheatre Parkway</street>
          <city>Mountain View</city>
          <region>CA</region>
          <code>94043</code>
	  <country>United States</country>
        </postal>
        <email>warren@kumari.net</email>
      </address>
    </author>

    <author fullname="Paul Hoffman" initials="P." surname="Hoffman">
      <organization>ICANN</organization>
      <address>
        <email>paul.hoffman@icann.org</email>
      </address>
    </author>

    <date month="June" year="2016" />

    <!-- If the month and year are both specified and are the current ones, xml2rfc will fill
          in the current day for you. If only the current year is specified, xml2rfc will fill
    in the current day and month for you. If the year is not the current one, it is
    necessary to specify at least a month (xml2rfc assumes day="1" if not specified for the
    purpose of calculating the expiry date).  With drafts it is normally sufficient to
    specify just the year. -->

    <!-- Meta-data Declarations -->

    <area>General</area>

    <workgroup>Internet Engineering Task Force</workgroup>

    <!-- WG name at the upperleft corner of the doc,
    IETF is fine for individual submissions.
    If this element is not present, the default is "Network Working Group",
    which is used by the RFC Editor as a nod to the history of the IETF. -->

    <keyword>DNS</keyword>
    <keyword>DNSSEC</keyword>
    <keyword>Key Tag</keyword>
    <keyword>Trust Anchor</keyword>
    <!-- Keywords will be incorporated into HTML output
    files in a meta tag but they have no effect on text or nroff
    output. If you submit your draft to the RFC Editor, the
    keywords will be used for the search engine. -->

<!-- text originally liberally borrowed from RFC 6975 -->

    <abstract>
      <t>
	The DNS Security Extensions (DNSSEC) were developed to provide
	origin authentication and integrity protection for DNS data
	by using digital signatures.  These digital signatures can be
	verified by building a chain-of-trust starting from a trust
	anchor and proceeding down to a particular node in the DNS.
	This document specifies a way for validating end-system
	resolvers to signal to a server which keys are referenced in
	their chain-of-trust.  The data from such signalling allow zone administrators
	to monitor the progress of rollovers in a DNSSEC-signed zone.
      </t>
    </abstract>
  </front>

  <middle>
    <section title="Introduction">
      <t>
	The DNS Security Extensions (DNSSEC) <xref target="RFC4033"/>,
	<xref target="RFC4034"/> and <xref target="RFC4035"/> were developed
	to provide origin
	authentication and integrity protection for DNS data by using digital
	signatures.  DNSSEC uses Key Tags to efficiently match signatures to
	the keys from which they are generated.  The Key Tag is a 16-bit
	value computed from the RDATA portion of a DNSKEY RR using a formula
	not unlike a ones-complement checksum.  RRSIG RRs contain a Key Tag
	field whose value is equal to the Key Tag of the DNSKEY RR that validates
	the signature.
      </t>
      <t>
	Likewise, Delegation Signer (DS) RRs also contain a Key Tag field whose
	value is equal to the Key Tag of the DNSKEY RR to which it refers.
      </t>
      <t>
	This draft specifies a way for validating DNS
	resolvers to tell the operator of a zone which DNSSEC key(s) they
	would use to validate responses from that zone.  This is done by periodically sending special "key tag queries"
	to a server authoritative for the zone.  The key tag query format is
	specified below in <xref target="query-format"/>.
	This new signalling mechanism is OPTIONAL to implement and use.
      </t>
      <t>
	Key tag queries serve to measure the
	acceptance and use of new DNSSEC trust anchors and key signing keys (KSKs).
	This signaling data can be used by zone administrators as a gauge
	to measure the successful deployment of new keys.  This is of particular
	interest for the DNS root zone in the event of key and/or algorithm rollovers that
	rely on <xref target="RFC5011"/> to automatically update a validating DNS resolver's
	trust anchor.
      </t>
      <t>
	This document does not introduce new processes for rolling keys or updating
	trust anchors.
	Rather, it specifies a means by which a DNS
	queriy can signal the set of keys that a client uses for DNSSEC validation.
      </t>
    </section>
    <section title="Requirements Terminology">
      <t>
        The key words "MUST", "MUST NOT", "REQUIRED", "SHALL", "SHALL NOT",
        "SHOULD", "SHOULD NOT", "RECOMMENDED", "MAY", and "OPTIONAL" in this
        document are to be interpreted as described in <xref
          target="RFC2119"/>.
      </t>
    </section>

    <section title="Terminology">
      <t>
      <list style="hanging">
	<t hangText="Trust Anchor:">A configured
	  DNSKEY RR or DS RR hash of a DNSKEY RR.  A validating
	  security-aware resolver uses this public key or hash as a
	  starting point for building the authentication chain to a
	  signed DNS response.  In general, a validating resolver
	  will have to obtain the initial values of its trust anchors
	  via some secure or trusted means outside the DNS protocol.
	  Presence of a trust anchor also implies that the resolver
	  should expect the zone to which the trust anchor points to
	  be signed. (quoted from <xref target="RFC4033"/> Section 2)</t>
	<t hangText="Key Tag:">A 16-bit integer that identifies and enables efficient
	  selection of DNSSEC public keys.  A Key Tag value can be
	  computed over the RDATA of a DNSKEY RR.  The Key Tag field
	  in the RRSIG and DS records can be used to help select
	  the corresponding DNSKEY RR efficiently when more than
	  one candidate DNSKEY RR is available.  For most algorithms
	  the Key Tag is a simple 16-bit modular sum of the DNSKEY
	  RDATA.  See <xref target="RFC4034"/> Appendix B.</t>
      </list>
      </t>
    </section>

    <section title="Query Format" anchor="query-format">
      <t>
	A key tag query consists of a standard DNS query of type NULL
        and of class IN <xref target="RFC1035"/>.
      </t>
      <t>
	The first component of the query name is the string "_ta-" followed
	by a hypen-separated list of hexadecimal-encoded Key Tag values.
	The zone name corresponding to the trust anchor is appended to this
	first component.
      </t>
      <t>
	For example, a validating DNS resolver that has a single root
	zone trust anchor with key tag 17476 (decimal) would originate
	a query of the form QTYPE=NULL, QCLASS=IN, QNAME=_ta-4444.
      </t>
      <t>
	A validating DNS resolver that has a three trust anchors for the
	example.com zone with key tags 31589, 43547, 31406 (decimal)
	would originate a query of the form QTYPE=NULL, QCLASS=IN,
	QNAME=_ta-7b65-aa1b-7aa3.example.com.
      </t>
	
    </section>

    <section title="Use By Queriers">
      <t>
	A validating DNS resolver (stub or recursive) SHOULD originate a key tag query
	whenever it also originates a DNSKEY query for a configured Trust Anchor zone.
	In other words, the need to issue a DNSKEY query is also the trigger to issue
	a key tag query.
      </t>
      <t>
	The value(s) included in the key tag query represent the
	Key Tag(s) of the Trust Anchor that will be used to validate the expected DNSKEY response.
      </t>
      <t>
	A DNS validating resolver SHOULD NOT originate key tag queries when also originating
	DNSKEY queries for non-Trust Anchor zones.
      </t>
      <t>
	A non-validating DNS resolver MUST NOT originate key tag queries.
      </t>
      <t>
	DNS resolvers with caches SHOULD cache and reuse the response to a key tag query
	just as it would any other response.
      </t>

    </section>

    <section title="Use By Responders">
      <t>
	An authoritative name server receiving key tag queries
	MAY log or otherwise collect the Key
	Tag values to provide information to the zone operator.
      </t>
      <t>
	An authoritative name server MUST generate an appropriate
	response to the key tag query.  Unless the zone operator has
	intentionally added "_ta-xxxx" records to the zone, the server
	MUST generate an NXDOMAIN response.  The zone operator might want
	to add specific key tag records to its zone, perhaps with specific TTLs,
	to affect the frequency of key tag queries from clients.
	[ Note RFC1035 says NULL RRs are not allowed in master files,
	but I believe that to be incorrect ]
      </t>
      <section title="Interaction With Aggressive Negative Caching">
        <t>
	  Aggressive NSEC/NSEC3 negative caching
	  [draft-fujiwara-dnsop-nsec-aggressiveuse] may also affect the
	  quality of key tag signalling.  When the response code for a key
	  tag query is NXDOMAIN, DNS resolvers that implement aggressive
	  negative caching will send fewer key tag queries than resolvers
	  that do not implement it.
        </t>
	<t>
	  For this reason, zone operators might choose to create records
	  corresponding to expected key tag queries.  During a rollover
	  from key tag 1111 (hex) to key tag 2222 (hex), the zone could
	  include the following records:
	  <figure>
	    <artwork align="left"><![CDATA[
_ta-1111        IN   NULL   \# 0
_ta-2222        IN   NULL   \# 0
_ta-1111-2222   IN   NULL   \# 0
_ta-2222-1111   IN   NULL   \# 0
	    ]]></artwork>
	  </figure>
	  [ most likely someone will suggest that key tag values should
	  be ordered to reduce the record count from 4 to 3 ]
	</t>
      </section>
    </section>

    <section title="IANA Considerations">
      <t>
	This document does not impose any requirements on IANA.
      </t>
    </section>

    <section anchor="Evolution" title="Design Evolution">
      <t>
	Initially this document was named draft-edns-key-tag and
	proposed including Key Tag values in a new EDNS(0) option
	code.  It was modeled after <xref target="RFC6975"/>, which
	provides DNSSEC algorithm signalling.
      </t>
      <t>
	The authors received feedback from Working Group participants
	that it might be better to convey Key Tags in QNAME of a
	separate DNS query, rather than as an EDNS(0) option.  Mostly
	this is because forwarding (e.g. from stub to recursive to
	authoritative) could be problematic.  Reasons include:
	<list style="numbers">
	  <t>
	    EDNS(0) is a hop-by-hop protocol.  Unknown option codes
	    would not be forwarded by default, as per <xref
	    target="RFC6891"/>.
	  </t>
	  <t>
	    Middleboxes might block entire queries containing unknown
	    EDNS(0) option codes.
	  </t>
	  <t>
	    A recursive might need to remember Key Tag values (i.e.,
	    keep state) received from its stub clients and then
	    forward them at a later opportunity.
	  </t>
	</list>
      </t>
      <t>
	One advantage of the EDNS(0) option code is that it is
	possible to see that a stub client has a different Key Tag
	list than its forwarder.  In the current QNAME-based approach,
	this is not possible because queries originated by a stub
	and a forwarder are indistinguishable.  The authors feel
	this advantage is not sufficient to justify the EDNS(0)
	approach.
      </t>
      <t>
	One downside to the QNAME approach is that it uses a separate
	query, whereas with EDNS(0) the Key Tag values are
	"piggy-backed" on to an existing DNSKEY query.  For this
	reason, this document recommends only sending key tag queries
	for configured trust anchors, whereas the earlier document
	allowed them to be sent with any DNSKEY query.
      </t>
      <t>
	Another downside, already discussed, is that since the trust
	anchor zone might not contain "_ta-xxxx" labels, these queries
	could be subject to aggressive negative caching features
	now in development by the Working Group.  This could affect
	the amount of signalling sent by some clients compared to
	others.
      </t>
    </section>


    <section title="Security Considerations" anchor="security">
      <t>
        This document specifies a way for a client to signal its trust anchor
        knowledge to a cache or server.  The signals
        are key tag queries whereby Key Tag values are encoded in the QNAME.  The
        purpose of these queries is to signal new trust anchor uptake in clients
        to allow zone administrators to know when it is possible to
        complete a key rollover in a DNSSEC-signed zone.
      </t>
      <t>
        There is a possibility that an eavesdropper or server could infer the
        validator in use by a client by the Key Tag list seen in queries.
	This may allow an attacker to find validators using old, possibly broken, keys.
        It could also be used to identify the
        validator or narrow down the possible validator implementations in
        use by a client, which could have a known vulnerability that could be
        exploited by the attacker.
      </t>
      <t>
	Consumers of data collected from the key tag queries
	are advised that provided Key Tag values might be "made up"
	by some DNS clients with malicious or at least mischievous
	intentions.
	For example, an attacker with sufficient
	resources might try to generate large numbers of queries
	including only old Key Tag values, with the intention of
	delaying the completion of a key rollover.
      </t>
      <t>
	DNSSEC does not require keys in a zone to have unique Key
	Tags.  During a rollover there is a small possibility that
	an old key and a new key will have identical Key Tag values.
	Zone operators relying on the key tag query data SHOULD
	take care to ensure that new keys have unique Key Tag values.
      </t>
    </section>

    <section title="Privacy Considerations" anchor="privacy">
      <t>
	This proposal adds additional, optional "signaling" from DNSSEC validators
	in the form of key tag queries.  While Key Tag values
	themselves are not considered private information, it may
	be possible for an eavesdropper to use Key Tag values as a
	fingerprinting technique to identify particular DNS validating
	clients.  This may be especially true if the validator is
	configured with trust anchor for zones in addition to the
	root zone.
      </t>
      <t>
	A validating DNS resolver need not transmit a
	key tag query in conjuntion with every corresponding DNSKEY query.  Due to
	privacy concerns, such a resolver MAY choose to transmit
	key tag queries less often (e.g., every
	25th time), or by random chance with a certain probability
	(e.g., 5%).
      </t>
      <t>
	Implementations of this specification MAY be administratively
	configured to only transmit key tag queries for
	certain zones.  For example, the software's configuration
	file may specify a list of zones for which key tag queries
	are allowed or denied.  Since the primary motivation for
	this specification is to provide operational measurement
	data for root zone key rollovers, it is RECOMMENDED that
	implementations at least send key tag queries in conjunction
	with root zone DNSKEY queries.
      </t>
    </section>

    <section anchor="Acknowledgments" title="Acknowledgments">
      <t>
	An early version of
	this document was inspired by and borrowed heavily from <xref target="RFC6975"/>
	by Scott Rose and Steve Crocker.  The authors would like to
	thank
	Mark Andrews,
	Casey Deccio,
	Burt Kalisky,
	Bob Harold,
	Edward Lewis,
	Tim Wicinski,
	Suzanne Woolf,
	and other members of
	the dnsop working group
	for their input.
      </t>
    </section>

  </middle>
  <back>

    <references title="Normative References">
    &RFC2119;
    &RFC1034;
    &RFC1035;
    &RFC4033;
    &RFC4034;
    &RFC4035;
    </references>

    <references title="Informative References">
    &RFC5011;
    &RFC6891;
    &RFC6975;
    </references>

    <section title="Changes / Author Notes.">
      <t>[RFC Editor: Please remove this section before publication]</t>

      <t>From -01 to -02:</t>
      <t>
	<list style="symbols">
	  <t>
	    Significantly rewritten to advocate a QNAME-based approach instead of
	    the EDNS-based approach.
	  </t>
          <t>
	    Added Paul Hoffman as coauthor.
	  </t>
	</list>
      </t>

      <t>From -00 to -01:</t>

      <t>
	<list style="symbols">
          <t>
	    Changed how a recursive should combine a stub's key tag
	    values with its own.  Previously it was to be a union
	    of key tag values.  Now it is a separate instance of
	    the option code for recursive and stub.
	  </t>

          <t>
	    Added Warren as coauthor.
	  </t>
        </list></t>
    </section>

  </back>
</rfc>
